\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\nimport \"./SubchainGovernanceToken.sol\";\n\ncontract WithdrawalQueue is Ownable {\n    using SafeMath for uint256;\n\n    struct WithdrawalRequest {\n        address receiver;\n        uint256 amount;\n        uint256 returnHeight;\n    }\n\n    event SlashQueuedWithdrawal(\n        address receiver,\n        uint256 slashAmount,\n        uint256 returnHeight\n    );\n\n    address public token;\n    mapping(address => WithdrawalRequest[]) public queueMap; // queues for each individual receiver accounts\n    address[] public receivers;\n\n    constructor(address token_, address owner_) Ownable(owner_) {\n        require(\n            token_ != address(0x0),\n            \"invalid token for the withdrawal queue\"\n        );\n        require(\n            owner_ != address(0x0),\n            \"invalid owner for the withdrawal queue\"\n        );\n        token = token_;\n    }\n\n    function enqueue(\n        address receiver,\n        uint256 withdrawalAmount,\n        uint256 returnHeight\n    ) external ownerOnly {\n        queueMap[receiver].push(\n            WithdrawalRequest(receiver, withdrawalAmount, returnHeight)\n        );\n        bool receiverExists = false;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            if (receivers[i] == receiver) {\n                receiverExists = true;\n                break;\n            }\n        }\n        if (!receiverExists) {\n            receivers.push(receiver);\n        }\n    }\n\n    function dequeue(address receiver)\n        external\n        ownerOnly\n        returns (WithdrawalRequest memory)\n    {\n        require(\n            queueMap[receiver].length > 0,\n            \"the withdrawal queue for the receiver should not be empty\"\n        ); // non-empty queue\n        uint256 numReceivers = receivers.length;\n        uint256 receiverIdx = 0;\n        bool matchFound = false;\n        for (; receiverIdx < numReceivers; receiverIdx++) {\n            if (receivers[receiverIdx] == receiver) {\n                matchFound = true;\n                break;\n            }\n        }\n        require(matchFound, \"no matched receiver found, cannot dequeue\");\n\n        WithdrawalRequest memory wr = queueMap[receiver][0];\n        for (uint256 i = 0; i < queueMap[receiver].length - 1; i++) {\n            queueMap[receiver][i] = queueMap[receiver][i + 1];\n        }\n        queueMap[receiver].pop();\n        if (queueMap[receiver].length == 0) {\n            delete queueMap[receiver];\n            for (; receiverIdx < numReceivers - 1; receiverIdx++) {\n                receivers[receiverIdx] = receivers[receiverIdx + 1];\n            }\n            receivers.pop();\n        }\n        return wr;\n    }\n\n    function slash(address receiver, uint256 expectedSlashAmount)\n        external\n        ownerOnly\n        returns (uint256 actualSlashedAmount)\n    {\n        actualSlashedAmount = 0;\n        for (uint256 i = 0; i < queueMap[receiver].length; i++) {\n            uint256 remaining = expectedSlashAmount.sub(actualSlashedAmount);\n            if (queueMap[receiver][i].amount <= remaining) {\n                emit SlashQueuedWithdrawal(\n                    receiver,\n                    queueMap[receiver][i].amount,\n                    queueMap[receiver][i].returnHeight\n                );\n                actualSlashedAmount = actualSlashedAmount.add(\n                    queueMap[receiver][i].amount\n                );\n                queueMap[receiver][i].amount = 0;\n            } else {\n                emit SlashQueuedWithdrawal(\n                    receiver,\n                    remaining,\n                    queueMap[receiver][i].returnHeight\n                );\n                actualSlashedAmount = actualSlashedAmount.add(remaining);\n                queueMap[receiver][i].amount = queueMap[receiver][i].amount.sub(\n                    remaining\n                );\n                break;\n            }\n        }\n\n        return actualSlashedAmount;\n    }\n\n    function top(address receiver)\n        external\n        view\n        returns (WithdrawalRequest memory)\n    {\n        WithdrawalRequest[] memory wrs = queueMap[receiver];\n        require(wrs.length > 0, \"the queue is empty\"); // non-empty queue\n        WithdrawalRequest memory wr = wrs[0];\n        return wr;\n    }\n\n    function isEmpty() external view returns (bool) {\n        return receivers.length == 0;\n    }\n\n    function allReceivers() external view returns (address[] memory) {\n        return receivers;\n    }\n\n    function getWithdrawalRequests(address receiver)\n        external\n        view\n        returns (WithdrawalRequest[] memory)\n    {\n        WithdrawalRequest[] memory wrs = queueMap[receiver];\n        return wrs;\n    }\n}\n\ncontract ValidatorCollateralManager is Ownable {\n    using SafeMath for uint256;\n\n    event ValidatorCollateralDeposit(\n        uint256 indexed subchainID,\n        address indexed validatorCandidate,\n        uint256 collateralAmoun,\n        address indexed guarantor\n    );\n    event ValidatorCollateralWithdrawal(\n        uint256 indexed subchainID,\n        address indexed validatorCandidate,\n        uint256 collateralAmount,\n        address indexed guarantor\n    );\n    event ValidatorCollateralReturn(\n        uint256 indexed subchainID,\n        uint256 collateralAmount,\n        address indexed guarantor\n    );\n    event SlashActiveCollateral(\n        uint256 indexed subchainID,\n        uint256 actualSlashedActiveCollateralAmount,\n        address indexed guarantor\n    );\n\n    uint256 public minValidatorCollateralAmount = 1000 ether;\n    uint256 public withdrawalPendingPeriodInBlocks;\n\n    address public wTheta;\n\n    // {chainID : validatorCandidateAddress}\n    mapping(uint256 => address[]) public validatorCandidates;\n\n    // {chainID : {validatorCandidateAddress : totalCollateral}}\n    mapping(uint256 => mapping(address => uint256)) public collaterals;\n\n    // {chainID : {validatorCandidateAddress : {guarantor : collateralAmount}}\n    mapping(uint256 => mapping(address => mapping(address => uint256)))\n        public guarantors;\n\n    // {chainID : withdrawalQueues}\n    mapping(uint256 => WithdrawalQueue) public withdrawalQueues;\n\n    constructor(\n        address owner_,\n        address wTheta_,\n        uint256 withdrawalPendingPeriodInBlocks_\n    ) Ownable(owner_) {\n        wTheta = wTheta_;\n        withdrawalPendingPeriodInBlocks = withdrawalPendingPeriodInBlocks_;\n    }\n\n    function depositCollateral(\n        uint256 subchainID,\n        address validatorCandidate,\n        uint256 collateralAmount,\n        address guarantor\n    ) external ownerOnly {\n        require(\n            IERC20(wTheta).transferFrom(\n                guarantor,\n                address(this),\n                collateralAmount\n            ),\n            \"failed to transfer wTHETA\"\n        );\n\n        uint256 totalCollateral = collaterals[subchainID][validatorCandidate];\n        totalCollateral = totalCollateral.add(collateralAmount);\n        require(\n            totalCollateral >= minValidatorCollateralAmount,\n            \"should meet the min collateral amount requirement\"\n        );\n        collaterals[subchainID][validatorCandidate] = totalCollateral;\n\n        uint256 collateralFromGuarantor = guarantors[subchainID][\n            validatorCandidate\n        ][guarantor];\n        collateralFromGuarantor = collateralFromGuarantor.add(collateralAmount);\n        guarantors[subchainID][validatorCandidate][\n            guarantor\n        ] = collateralFromGuarantor;\n\n        bool candidateExists = false;\n        for (uint256 i = 0; i < validatorCandidates[subchainID].length; i++) {\n            if (validatorCandidates[subchainID][i] == validatorCandidate) {\n                candidateExists = true;\n                break;\n            }\n        }\n        if (!candidateExists) {\n            validatorCandidates[subchainID].push(validatorCandidate);\n        }\n\n        emit ValidatorCollateralDeposit(\n            subchainID,\n            validatorCandidate,\n            collateralAmount,\n            guarantor\n        );\n    }\n\n    function withdrawCollateral(\n        uint256 subchainID,\n        address validatorCandidate,\n        uint256 collateralAmount,\n        address guarantor\n    ) external ownerOnly {\n        uint256 totalCollateral = collaterals[subchainID][validatorCandidate];\n        require(\n            totalCollateral >= collateralAmount,\n            \"not enough collateral remained for the validator\"\n        );\n        totalCollateral = totalCollateral.sub(collateralAmount);\n        // either withdraw all the collateral, or leave a sufficient amount\n        require(\n            totalCollateral == 0 ||\n                totalCollateral >= minValidatorCollateralAmount,\n            \"invalid collateral withdrawal amount\"\n        );\n        collaterals[subchainID][validatorCandidate] = totalCollateral;\n\n        uint256 collateralFromGuarantor = guarantors[subchainID][\n            validatorCandidate\n        ][guarantor];\n        require(\n            collateralFromGuarantor >= collateralAmount,\n            \"guarantor's remaining collateral is lower than the withdrawal amount\"\n        );\n        collateralFromGuarantor = collateralFromGuarantor.sub(collateralAmount);\n        guarantors[subchainID][validatorCandidate][\n            guarantor\n        ] = collateralFromGuarantor;\n\n        // enqueue collateral withdrawal request\n        if (address(withdrawalQueues[subchainID]) == address(0)) {\n            withdrawalQueues[subchainID] = new WithdrawalQueue(\n                wTheta,\n                address(this)\n            );\n        }\n        uint256 collateralReturnHeight = block.number +\n            withdrawalPendingPeriodInBlocks;\n        withdrawalQueues[subchainID].enqueue(\n            guarantor,\n            collateralAmount,\n            collateralReturnHeight\n        );\n\n        emit ValidatorCollateralWithdrawal(\n            subchainID,\n            validatorCandidate,\n            collateralAmount,\n            guarantor\n        );\n    }\n\n    function claimCollateral(uint256 subchainID, address guarantor)\n        external\n        ownerOnly\n    {\n        require(\n            address(withdrawalQueues[subchainID]) != address(0),\n            \"the withdrawal queue does not exist for the subchain, has any collateral been withdrawn yet?\"\n        );\n        require(\n            block.number >=\n                withdrawalQueues[subchainID].top(guarantor).returnHeight,\n            \"no collateral is ready to be claimed for the guarantor\"\n        );\n        WithdrawalQueue.WithdrawalRequest memory wr = withdrawalQueues[\n            subchainID\n        ].dequeue(guarantor);\n        uint256 collateralAmount = wr.amount;\n        require(\n            IERC20(wTheta).transfer(guarantor, collateralAmount),\n            \"failed to transfer wTHETA\"\n        );\n\n        emit ValidatorCollateralReturn(subchainID, collateralAmount, guarantor);\n    }\n\n    function slashCollateral(\n        uint256 subchainID,\n        address validatorCandidate,\n        address guarantor,\n        uint256 slashAmount\n    ) external ownerOnly returns (uint256 actualSlashedAmount) {\n        actualSlashedAmount = 0;\n\n        uint256 activeCollateral = guarantors[subchainID][validatorCandidate][\n            guarantor\n        ];\n        uint256 activeCollateralToBeSlashed = slashAmount;\n        if (activeCollateral < slashAmount) {\n            activeCollateralToBeSlashed = activeCollateral;\n        }\n\n        // slash active collateral\n        guarantors[subchainID][validatorCandidate][guarantor] = activeCollateral\n            .sub(activeCollateralToBeSlashed);\n        collaterals[subchainID][validatorCandidate] = collaterals[subchainID][\n            validatorCandidate\n        ].sub(activeCollateralToBeSlashed); // this should always hold: collaterals[subchainID][validatorCandidate] >= guarantors[subchainID][validatorCandidate][guarantor]\n        actualSlashedAmount = actualSlashedAmount.add(\n            activeCollateralToBeSlashed\n        );\n\n        emit SlashActiveCollateral(\n            subchainID,\n            activeCollateralToBeSlashed,\n            guarantor\n        );\n\n        // slash collaterals in the withdrawal queue if needed\n        if (activeCollateral < slashAmount) {\n            uint256 queuedCollateralToBeSlashed = slashAmount.sub(\n                activeCollateralToBeSlashed\n            );\n            if (address(withdrawalQueues[subchainID]) != address(0)) {\n                uint256 amountSlashedFromQueue = withdrawalQueues[subchainID]\n                    .slash(guarantor, queuedCollateralToBeSlashed);\n                actualSlashedAmount = actualSlashedAmount.add(\n                    amountSlashedFromQueue\n                );\n            }\n        }\n\n        return actualSlashedAmount;\n    }\n\n    function updateMinValidatorCollateralAmount(uint256 amount)\n        external\n        ownerOnly\n    {\n        minValidatorCollateralAmount = amount;\n    }\n\n    function getCollateralAmount(uint256 subchainID, address validatorCandidate)\n        public\n        view\n        returns (uint256)\n    {\n        return collaterals[subchainID][validatorCandidate];\n    }\n\n    function getWithdrawalQueue(uint256 subchainID)\n        external\n        view\n        returns (WithdrawalQueue)\n    {\n        return withdrawalQueues[subchainID];\n    }\n\n    function hasValidatorCollaterals(uint256 subchainID)\n        public\n        view\n        returns (bool)\n    {\n        // check active collaterals\n        for (uint256 i = 0; i < validatorCandidates[subchainID].length; i++) {\n            address validatorCandidate = validatorCandidates[subchainID][i];\n            if (collaterals[subchainID][validatorCandidate] > 0) {\n                return true;\n            }\n        }\n\n        // check pending collaterals, if the withdrawal queue exists\n        if (withdrawalQueues[subchainID] != WithdrawalQueue(address(0x0))) {\n            if (!withdrawalQueues[subchainID].isEmpty()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\ncontract ValidatorStakeManager is Ownable {\n    using SafeMath for uint256;\n\n    event ValidatorStakeDeposit(\n        uint256 indexed subchainID,\n        address subchainGovernanceToken,\n        address indexed validator,\n        uint256 govTokenAmount,\n        uint256 shareAmount,\n        address indexed staker\n    );\n    event ValidatorStakeWithdrawal(\n        uint256 indexed subchainID,\n        address subchainGovernanceToken,\n        address indexed validator,\n        uint256 govTokenAmount,\n        uint256 shareAmount,\n        address indexed staker\n    );\n    event ValidatorStakeReturn(\n        uint256 indexed subchainID,\n        address subchainGovernanceToken,\n        uint256 govTokenAmount,\n        address indexed staker\n    );\n\n    struct Stake {\n        address validator;\n        uint256 shareAmount;\n    }\n\n    struct StakeSnapshot {\n        uint256 height;\n        Stake[] stakes;\n    }\n\n    uint256 public numBlocksPerDynasty;\n    uint256 public withdrawalPendingPeriodInBlocks;\n    ChainRegistrarOnMainchain public chainRegistrarOnMainchain;\n\n    // {chainID : {stakingHeight : stakeSnapshot}}\n    mapping(uint256 => mapping(uint256 => StakeSnapshot)) stakingHistory;\n\n    // {chainID : []snapshotHeight}\n    mapping(uint256 => uint256[]) public snapshotHeights;\n\n    // {chainID : {validatorAddress : {staker : shareAmount}}\n    mapping(uint256 => mapping(address => mapping(address => uint256)))\n        public validatorShares;\n\n    // {chainID : share}\n    mapping(uint256 => uint256) totalShares; // the current total shares for each subchain\n\n    // {chainID : {staker : share}}\n    mapping(uint256 => mapping(address => uint256)) shares; // the current shares of each staker\n\n    // {chainID : height}\n    mapping(uint256 => uint256) lastRewardMintHeights; // for staking reward calculation\n\n    // {chainID : withdrawalQueues}\n    mapping(uint256 => WithdrawalQueue) public withdrawalQueues;\n\n    constructor(\n        address owner_,\n        address chainRegistrarOnMainchain_,\n        uint256 numBlocksPerDynasty_,\n        uint256 withdrawalPendingPeriodInBlocks_\n    ) Ownable(owner_) {\n        numBlocksPerDynasty = numBlocksPerDynasty_;\n        withdrawalPendingPeriodInBlocks = withdrawalPendingPeriodInBlocks_;\n        chainRegistrarOnMainchain = ChainRegistrarOnMainchain(\n            chainRegistrarOnMainchain_\n        );\n    }\n\n    function depositStake(\n        uint256 subchainID,\n        address validator,\n        uint256 govTokenAmount,\n        address staker\n    ) external ownerOnly {\n        ChainRegistrarOnMainchain.SubchainMetadata\n            memory subchainMetadata = chainRegistrarOnMainchain\n                .getSubchainMetadata(subchainID);\n        require(\n            subchainMetadata.exists,\n            \"the subchainID is not registered yet\"\n        );\n        SubchainGovernanceToken subchainGovernanceToken = subchainMetadata\n            .governanceToken;\n\n        if (lastRewardMintHeights[subchainID] == 0) {\n            lastRewardMintHeights[subchainID] = block.number; // reward calculation starts at the time of the first stake deposit\n        }\n        updateReward(subchainID); // make sure reward is up-to-date so that share price is accurate.\n        uint256 prevPoolGovTokenBalance = subchainGovernanceToken.balanceOf(\n            address(this)\n        );\n\n        require(\n            subchainGovernanceToken.transferFrom(\n                staker,\n                address(this),\n                govTokenAmount\n            ),\n            \"failed to transfer subchain governance token\"\n        );\n\n        // update staker shares\n        uint256 newShares;\n        if (totalShares[subchainID] == 0) {\n            newShares = govTokenAmount;\n        } else {\n            uint256 pendingAmount = this.getPendingGovernanceTokenAmount(\n                subchainID\n            );\n            require(\n                pendingAmount < prevPoolGovTokenBalance,\n                \"invalid pending amount\"\n            );\n\n            newShares = totalShares[subchainID].mul(govTokenAmount).div(\n                (prevPoolGovTokenBalance.sub(pendingAmount))\n            );\n        }\n        totalShares[subchainID] = totalShares[subchainID].add(newShares);\n        shares[subchainID][staker] = shares[subchainID][staker].add(newShares);\n\n        // update staking history (use scope here to limit variable lifetime in order to avoid the \"stack too deep\" compilation error)\n        {\n            uint256 blockHeight = block.number;\n            (, , StakeSnapshot memory ss) = this.getStakeSnapshot(\n                subchainID,\n                blockHeight\n            );\n            stakingHistory[subchainID][blockHeight].height = blockHeight;\n\n            bool isExistingValidator = false;\n            for (uint256 i = 0; i < ss.stakes.length; i++) {\n                uint256 valShares = ss.stakes[i].shareAmount;\n                if (ss.stakes[i].validator == validator) {\n                    valShares = valShares.add(newShares);\n                    isExistingValidator = true;\n                }\n                stakingHistory[subchainID][blockHeight].stakes.push(\n                    Stake(ss.stakes[i].validator, valShares)\n                );\n            }\n            if (!isExistingValidator) {\n                stakingHistory[subchainID][blockHeight].stakes.push(\n                    Stake(validator, newShares)\n                );\n            }\n\n            // update stake change heights\n            snapshotHeights[subchainID].push(blockHeight);\n        }\n\n        // update validator shares\n        uint256 stakerShares = validatorShares[subchainID][validator][staker];\n        stakerShares = stakerShares.add(newShares);\n        validatorShares[subchainID][validator][staker] = stakerShares;\n\n        emit ValidatorStakeDeposit(\n            subchainID,\n            address(subchainGovernanceToken),\n            validator,\n            govTokenAmount,\n            newShares,\n            staker\n        );\n    }\n\n    function withdrawStake(\n        uint256 subchainID,\n        address validator,\n        uint256 shareAmount,\n        address staker\n    ) external ownerOnly {\n        require(shareAmount > 0, \"invalid share amount\");\n        require(\n            totalShares[subchainID] >= shareAmount,\n            \"the subchain does not have sufficient shares to withdraw\"\n        );\n        require(\n            shares[subchainID][staker] >= shareAmount,\n            \"the staker does not have sufficient shares to withdraw\"\n        );\n        updateReward(subchainID); // make sure reward is up-to-date so that share price is accurate.\n        ChainRegistrarOnMainchain.SubchainMetadata\n            memory subchainMetadata = chainRegistrarOnMainchain\n                .getSubchainMetadata(subchainID);\n        SubchainGovernanceToken subchainGovernanceToken = subchainMetadata\n            .governanceToken;\n        uint256 poolGovTokenBalance = subchainGovernanceToken.balanceOf(\n            address(this)\n        );\n\n        uint256 govTokenAmount;\n        {\n            uint256 pendingAmount = this.getPendingGovernanceTokenAmount(\n                subchainID\n            );\n            require(\n                pendingAmount <= poolGovTokenBalance,\n                \"invalid pending amount\"\n            );\n\n            govTokenAmount = (poolGovTokenBalance.sub(pendingAmount))\n                .mul(shareAmount)\n                .div(totalShares[subchainID]);\n        }\n\n        // update staker shares\n        totalShares[subchainID] = totalShares[subchainID].sub(shareAmount);\n        shares[subchainID][staker] = shares[subchainID][staker].sub(\n            shareAmount\n        );\n\n        // update staking history (use scope here to limit variable lifetime in order to avoid the \"stack too deep\" compilation error)\n        {\n            uint256 blockHeight = block.number;\n            (bool exists, , StakeSnapshot memory ss) = this.getStakeSnapshot(\n                subchainID,\n                block.number\n            );\n            require(exists, \"no stake snapshot exits, cannot withdraw stake\");\n            stakingHistory[subchainID][blockHeight].height = blockHeight;\n\n            bool isExistingValidator = false;\n            for (uint256 i = 0; i < ss.stakes.length; i++) {\n                uint256 valShares = ss.stakes[i].shareAmount;\n                if (ss.stakes[i].validator == validator) {\n                    require(\n                        valShares >= shareAmount,\n                        \"validator's remaining share lower than the withdrawal amount\"\n                    );\n                    valShares = valShares.sub(shareAmount);\n                    isExistingValidator = true;\n                }\n                if (valShares > 0) {\n                    // otherwise if valShares == 0, we can simply skip the validator\n                    stakingHistory[subchainID][blockHeight].stakes.push(\n                        Stake(ss.stakes[i].validator, valShares)\n                    );\n                }\n            }\n\n            require(\n                isExistingValidator,\n                \"cannot unstake from a non-validator node\"\n            );\n\n            // update stake change heights\n            snapshotHeights[subchainID].push(block.number);\n        }\n\n        // update validator shares\n        uint256 stakerShares = validatorShares[subchainID][validator][staker];\n        require(stakerShares >= shareAmount, \"not enough remaining share\");\n        stakerShares = stakerShares.sub(shareAmount);\n        validatorShares[subchainID][validator][staker] = stakerShares;\n\n        // enqueue stake withdrawal request\n        if (address(withdrawalQueues[subchainID]) == address(0)) {\n            require(\n                subchainMetadata.exists,\n                \"the subchainID is not registered yet\"\n            );\n            withdrawalQueues[subchainID] = new WithdrawalQueue(\n                address(subchainGovernanceToken),\n                address(this)\n            );\n        }\n        uint256 stakeReturnHeight = block.number +\n            withdrawalPendingPeriodInBlocks;\n        withdrawalQueues[subchainID].enqueue(\n            staker,\n            govTokenAmount,\n            stakeReturnHeight\n        );\n\n        emit ValidatorStakeWithdrawal(\n            subchainID,\n            address(subchainMetadata.governanceToken),\n            validator,\n            govTokenAmount,\n            shareAmount,\n            staker\n        );\n    }\n\n    function getPendingGovernanceTokenAmount(uint256 subchainID)\n        external\n        view\n        returns (uint256)\n    {\n        if (address(withdrawalQueues[subchainID]) == address(0)) {\n            return 0;\n        }\n\n        uint256 totalPendingAmount = 0;\n        WithdrawalQueue wq = withdrawalQueues[subchainID];\n        address[] memory allReceivers = wq.allReceivers();\n        for (uint256 i = 0; i < allReceivers.length; i++) {\n            address receiver = allReceivers[i];\n            WithdrawalQueue.WithdrawalRequest[] memory wrs = wq\n                .getWithdrawalRequests(receiver);\n            for (uint256 j = 0; j < wrs.length; j++) {\n                totalPendingAmount = totalPendingAmount.add(wrs[j].amount);\n            }\n        }\n\n        return totalPendingAmount;\n    }\n\n    function claimStake(uint256 subchainID, address staker) external ownerOnly {\n        require(\n            address(withdrawalQueues[subchainID]) != address(0),\n            \"the withdrawal queue does not exist for the subchain, has any stake been withdrawn yet?\"\n        );\n        require(\n            block.number >=\n                withdrawalQueues[subchainID].top(staker).returnHeight,\n            \"no stake is ready to be claimed for the staker\"\n        );\n        WithdrawalQueue.WithdrawalRequest memory wr = withdrawalQueues[\n            subchainID\n        ].dequeue(staker);\n        uint256 govTokenAmount = wr.amount;\n\n        ChainRegistrarOnMainchain.SubchainMetadata\n            memory subchainMetadata = chainRegistrarOnMainchain\n                .getSubchainMetadata(subchainID);\n        require(\n            subchainMetadata.exists,\n            \"the subchainID is not registered yet\"\n        );\n        address subchainGovernanceToken = address(\n            subchainMetadata.governanceToken\n        );\n        require(\n            IERC20(subchainGovernanceToken).transfer(staker, govTokenAmount),\n            \"failed to transfer subchain governance token\"\n        );\n\n        emit ValidatorStakeReturn(\n            subchainID,\n            subchainGovernanceToken,\n            govTokenAmount,\n            staker\n        );\n    }\n\n    // getStakeSnapshot returns the latest stake snapshot before the given block height. For example, if there were stake deposit/withdrawal for subchain 8888\n    // happened at height 2155, 3286, and 3899, then getStakeSnapshot(8888, 3000) returns the stake snapshot at height 2155,  getStakeSnapshot(8888, 3950)\n    // returns the stake snapshot at height 3899. Note that this function returns the targetSnapshotHeight along with targetStakeSnapshot. With targetSnapshotHeight,\n    // if the caller needs targetStakeSnapshot as a \"storage\" type of data, it can targetSnapshotHeight to look it up.\n    function getStakeSnapshot(uint256 subchainID, uint256 blockHeight)\n        external\n        view\n        returns (\n            bool exists,\n            uint256 targetSnapshotHeight,\n            StakeSnapshot memory targetStakeSnapshot\n        )\n    {\n        uint256[] storage heights = snapshotHeights[subchainID];\n        if (heights.length == 0) {\n            return (false, 0, targetStakeSnapshot);\n        }\n        if (blockHeight < heights[0]) {\n            return (false, 0, targetStakeSnapshot);\n        }\n        uint256 mostRecentSnapshotHeight = heights[heights.length - 1];\n        if (mostRecentSnapshotHeight <= blockHeight) {\n            // gas optimization for a common use case which queries for the current block height: getStakeSnapshot(subchainID, block.number)\n            return (\n                true,\n                mostRecentSnapshotHeight,\n                stakingHistory[subchainID][mostRecentSnapshotHeight]\n            );\n        }\n\n        uint256 lower = 0;\n        uint256 upper = heights.length - 1;\n        targetSnapshotHeight = heights[lower];\n        while (upper > lower) {\n            // binary search\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            uint256 snapshotHeight = heights[center];\n            if (snapshotHeight == blockHeight) {\n                targetSnapshotHeight = snapshotHeight;\n                break;\n            } else if (snapshotHeight < blockHeight) {\n                lower = center;\n                targetSnapshotHeight = heights[lower];\n            } else {\n                upper = center - 1;\n                targetSnapshotHeight = heights[lower];\n            }\n        }\n        targetStakeSnapshot = stakingHistory[subchainID][targetSnapshotHeight];\n        return (true, targetSnapshotHeight, targetStakeSnapshot);\n    }\n\n    function getWithdrawalQueue(uint256 subchainID)\n        external\n        view\n        returns (WithdrawalQueue)\n    {\n        return withdrawalQueues[subchainID];\n    }\n\n    function getStakeSnapshotHeights(uint256 subchainID)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return snapshotHeights[subchainID];\n    }\n\n    function getValidatorSet(uint256 subchainID, uint256 dynasty)\n        external\n        view\n        returns (address[] memory validators, uint256[] memory shareAmounts)\n    {\n        uint256 prevDynastyEndingHeight;\n        if (dynasty == 0) {\n            prevDynastyEndingHeight = 0; // special handling\n        } else {\n            prevDynastyEndingHeight = numBlocksPerDynasty * dynasty - 1;\n        }\n        // Stake deposit/withdrawal in a dynasty becomes effective only when the next dynasty starts. Hence,\n        // we should use the ending height of the last dynasty to retrieve the validator set of the current dynasty\n        (, , StakeSnapshot memory stakeSnapshot) = this.getStakeSnapshot(\n            subchainID,\n            prevDynastyEndingHeight\n        );\n        uint256 numValidators = stakeSnapshot.stakes.length;\n\n        validators = new address[](numValidators);\n        shareAmounts = new uint256[](numValidators);\n        for (uint256 i = 0; i < numValidators; i++) {\n            Stake memory stake = stakeSnapshot.stakes[i];\n            validators[i] = stake.validator;\n            shareAmounts[i] = stake.shareAmount;\n        }\n        return (validators, shareAmounts);\n    }\n\n    // function to retrieve the amount of shares of validator on a given subchain during a dynasty\n    function getValidatorShares(\n        uint256 subchainID,\n        uint256 dynasty,\n        address addr\n    ) external view returns (bool isAValidator, uint256 shareAmount) {\n        (address[] memory validators, uint256[] memory shareAmounts) = this\n            .getValidatorSet(subchainID, dynasty);\n        uint256 numValidators = validators.length;\n        for (uint256 i = 0; i < numValidators; i++) {\n            if (validators[i] == addr) {\n                return (true, shareAmounts[i]);\n            }\n        }\n        return (false, 0);\n    }\n\n    // function to retrieve the amount of shares from a staker for a validator on a given subchain\n    function getStakerShares(\n        uint256 subchainID,\n        address validator,\n        address staker\n    ) external view returns (uint256) {\n        uint256 stakerShares = validatorShares[subchainID][validator][staker];\n        return stakerShares;\n    }\n\n    // stake change becomes effective at the first block in the next dynasty\n    function getDynastyStartingHeight(uint256 blockHeight)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 dynasty = blockHeight.div(numBlocksPerDynasty);\n        uint256 startingHeight = dynasty.mul(numBlocksPerDynasty);\n        return startingHeight;\n    }\n\n    function totalShareOf(uint256 subchainID) external view returns (uint256) {\n        return totalShares[subchainID];\n    }\n\n    function shareOf(uint256 subchainID, address staker)\n        external\n        view\n        returns (uint256)\n    {\n        return shares[subchainID][staker];\n    }\n\n    // function to estmiated the amount of governance tokens owned by the staker with\n    // the staking rewards taken into account\n    function estimatedGovernanceTokenOwnedBy(uint256 subchainID, address staker)\n        external\n        view\n        returns (uint256)\n    {\n        if (totalShares[subchainID] == 0) {\n            return 0;\n        }\n        ChainRegistrarOnMainchain.SubchainMetadata\n            memory subchainMetadata = chainRegistrarOnMainchain\n                .getSubchainMetadata(subchainID);\n        SubchainGovernanceToken subchainGovernanceToken = subchainMetadata\n            .governanceToken;\n\n        uint256 currentHeight = block.number;\n        uint256 totalRewardSinceLastMint = 0;\n        uint256 lastRewardMintHeight = lastRewardMintHeights[subchainID];\n        if (currentHeight >= lastRewardMintHeight) {\n            totalRewardSinceLastMint = subchainGovernanceToken\n                .stakerRewardPerBlock()\n                .mul(currentHeight.sub(lastRewardMintHeight));\n        }\n\n        uint256 accountShares = shares[subchainID][staker];\n        uint256 estimatedPoolGovTokenBalance = subchainGovernanceToken\n            .balanceOf(address(this))\n            .add(totalRewardSinceLastMint);\n        uint256 pendingAmount = this.getPendingGovernanceTokenAmount(\n            subchainID\n        );\n        require(\n            pendingAmount <= estimatedPoolGovTokenBalance,\n            \"invalid pending amount\"\n        );\n\n        uint256 estimatedAccountGovTokenBalance = (\n            (estimatedPoolGovTokenBalance.sub(pendingAmount)).mul(accountShares)\n        ).div(totalShares[subchainID]);\n\n        return estimatedAccountGovTokenBalance;\n    }\n\n    function updateReward(uint256 subchainID) private {\n        uint256 lastRewardMintHeight = lastRewardMintHeights[subchainID];\n        if (lastRewardMintHeight >= block.number) {\n            return;\n        }\n\n        ChainRegistrarOnMainchain.SubchainMetadata\n            memory subchainMetadata = chainRegistrarOnMainchain\n                .getSubchainMetadata(subchainID);\n        require(\n            subchainMetadata.exists,\n            \"the subchainID is not registered yet\"\n        );\n        SubchainGovernanceToken subchainGovernanceToken = subchainMetadata\n            .governanceToken;\n        if (\n            !this.hasImplementedStakerReward(address(subchainGovernanceToken))\n        ) {\n            return;\n        }\n\n        uint256 numBlocksElapsed = block.number.sub(lastRewardMintHeight);\n        uint256 amount = subchainGovernanceToken.stakerRewardPerBlock().mul(\n            numBlocksElapsed\n        );\n\n        lastRewardMintHeights[subchainID] = block.number;\n        subchainGovernanceToken.mintStakerReward(address(this), amount);\n    }\n\n    // Check the existence of a contract method\n    // Reference: https://ethereum.stackexchange.com/questions/83991/how-do-i-check-for-the-existence-of-a-function-in-solidity-when-i-have-an-addres\n    bytes4 private constant STAKER_REWARD_PER_BLOCK_FUNC_SELECTOR =\n        bytes4(keccak256(\"stakerRewardPerBlock()\"));\n\n    function hasImplementedStakerReward(address token) public returns (bool) {\n        bool success;\n        bytes memory data = abi.encodeWithSelector(\n            STAKER_REWARD_PER_BLOCK_FUNC_SELECTOR\n        );\n        assembly {\n            success := call(\n                gas(), // gas remaining\n                token, // destination address\n                0, // no ether\n                add(data, 32), // input buffer (starts after the first 32 bytes in the `data` array)\n                mload(data), // input length (loaded from the first 32 bytes in the `data` array)\n                0, // output buffer\n                0 // output length\n            )\n        }\n        return success;\n    }\n}\n\ncontract ChainRegistrarOnMainchain is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    struct SubchainMetadata {\n        address guarantor;\n        uint256 collateralAmount;\n        SubchainGovernanceToken governanceToken;\n        string genesisHash;\n        uint256 registrationHeight;\n        bool exists;\n    }\n\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    event SlashChainCollateral(uint256 subchainID, uint256 slashAmount);\n    event SlashValidatorCollateral(\n        uint256 subchainID,\n        address validator,\n        address guarantor,\n        uint256 actualSlashedAmount\n    );\n\n    uint256 public minSubchainID = 1000; // do not allow registering a subchainID < 1000, otherwise it might conflict with the mainchain ID\n    uint256 public minChainCollateralAmount = 10000 ether;\n    uint256 public numBlocksPerDynasty;\n    uint256 public withdrawalPendingPeriodInBlocks;\n\n    address public wTheta; // wrapped Theta\n    address public superAdmin;\n    address public admin;\n    address public governor;\n    uint256 public crossChainFee;\n    uint256 public initialFeeRequired; // we require the stakers to deposit a certain amount of TFuel to the validators to cover the initial cross-chain fee\n    address public fallbackReceiver; // fallback address in case sending token to the specified receiver failed\n    uint256 public subchainCollateralReturnPercentage; // a number between 0 and 100, which specifies the percentage of\n    // collaterals to be returned when the subchain is deregistered. This is to prevent malicous actors from exhausting all\n    // usable subchainIDs by quickly registering/deregistering subchains.\n\n    // {chainID : subchainMetadata}\n    mapping(uint256 => SubchainMetadata) public subchainMetadataMap;\n    uint256[] public subchainIDs;\n\n    ValidatorCollateralManager public vcm;\n    ValidatorStakeManager public vsm;\n\n    constructor(\n        address wTheta_,\n        address superAdmin_,\n        address admin_,\n        address governor_,\n        uint256 numBlocksPerDynasty_,\n        uint256 withdrawalPendingPeriodInBlocks_,\n        uint256 crossChainFee_,\n        uint256 initialFeeRequired_,\n        address fallbackReceiver_\n    ) {\n        wTheta = wTheta_;\n        superAdmin = superAdmin_;\n        admin = admin_;\n        governor = governor_;\n        numBlocksPerDynasty = numBlocksPerDynasty_;\n        withdrawalPendingPeriodInBlocks = withdrawalPendingPeriodInBlocks_;\n        crossChainFee = crossChainFee_;\n        initialFeeRequired = initialFeeRequired_;\n        fallbackReceiver = fallbackReceiver_;\n        vcm = new ValidatorCollateralManager(\n            address(this),\n            wTheta_,\n            withdrawalPendingPeriodInBlocks_\n        );\n        vsm = new ValidatorStakeManager(\n            address(this),\n            address(this),\n            numBlocksPerDynasty_,\n            withdrawalPendingPeriodInBlocks_\n        );\n        subchainCollateralReturnPercentage = uint256(95); // return 95% by default\n    }\n\n    //\n    // Subchain registration\n    //\n\n    function registerSubchain(\n        uint256 subchainID,\n        address governanceToken,\n        uint256 collateralAmount,\n        string memory genesisHash\n    ) external nonReentrant {\n        require(subchainID > minSubchainID, \"This subchainID is not allowed\");\n        SubchainMetadata storage subchainMetadata = subchainMetadataMap[\n            subchainID\n        ];\n        require(\n            !subchainMetadata.exists,\n            \"this subchain ID has already been registered\"\n        );\n        require(\n            collateralAmount >= minChainCollateralAmount,\n            \"insufficient wTHETA collateral for the subchain\"\n        );\n        address chainGuarantor = msg.sender;\n        require(\n            IERC20(wTheta).transferFrom(\n                chainGuarantor,\n                address(this),\n                collateralAmount\n            ),\n            \"failed to transfer wTHETA\"\n        );\n        subchainMetadataMap[subchainID] = SubchainMetadata(\n            chainGuarantor,\n            collateralAmount,\n            SubchainGovernanceToken(governanceToken),\n            genesisHash,\n            block.number,\n            true\n        );\n        subchainIDs.push(subchainID);\n    }\n\n    // allow the subchain guarantor to add more collateral to bolster user confidence\n    function addSubchainCollateral(\n        uint256 subchainID,\n        uint256 additionalCollateral\n    ) external nonReentrant {\n        SubchainMetadata memory subchainMetadata = subchainMetadataMap[\n            subchainID\n        ];\n        require(\n            subchainMetadata.exists,\n            \"this subchain ID has not been registered yet\"\n        );\n        require(\n            msg.sender == subchainMetadata.guarantor,\n            \"only subchain guarantor can add more collateral\"\n        );\n        require(\n            IERC20(wTheta).transferFrom(\n                msg.sender,\n                address(this),\n                additionalCollateral\n            ),\n            \"failed to transfer wTHETA\"\n        );\n        subchainMetadataMap[subchainID].collateralAmount = subchainMetadataMap[\n            subchainID\n        ].collateralAmount.add(additionalCollateral);\n    }\n\n    // before calling deregisterSubchain(), all stakes and collaterals of the subchain's validators need to be fully withdrawn\n    function deregisterSubchain(uint256 subchainID) external nonReentrant {\n        require(\n            !vcm.hasValidatorCollaterals(subchainID),\n            \"cannot unregister a subchain when some validators still have active or unclaimed collaterals\"\n        );\n        SubchainMetadata memory subchainMetadata = subchainMetadataMap[\n            subchainID\n        ];\n        require(\n            subchainMetadata.exists,\n            \"the subchainID is not registered yet\"\n        );\n        address chainGuarantor = subchainMetadata.guarantor;\n        require(\n            msg.sender == chainGuarantor,\n            \"only subchain guarantor can deregister the subchain\"\n        );\n        uint256 collateralAmount = subchainMetadata.collateralAmount;\n        uint256 returnAoumnt = collateralAmount\n            .mul(subchainCollateralReturnPercentage)\n            .div(100);\n        require(\n            IERC20(wTheta).transfer(chainGuarantor, returnAoumnt),\n            \"failed to transfer wTHETA\"\n        );\n\n        // Note: we purposely don't delete the subchainID here, as allowing\n        //       subchainID reuse might create oppurtunities for replay attacks\n\n        // // delete from subchainMetadataMap\n        // delete subchainMetadataMap[subchainID];\n\n        // // delete from subchainIDs\n        // uint256 numSubchains = subchainIDs.length;\n        // bool matchFound = false;\n        // for (uint256 idx = 0; idx < numSubchains; idx++) {\n        //     if (subchainIDs[idx] == subchainID) {\n        //         matchFound = true;\n        //     }\n        //     if (matchFound && (idx != numSubchains - 1)) {\n        //         subchainIDs[idx] = subchainIDs[idx + 1];\n        //     }\n        // }\n        // require(matchFound, \"subchainID not found\");\n        // subchainIDs.pop();\n    }\n\n    //\n    // Validator candidate collateral deposit/withdrawal/claim\n    //\n\n    function depositCollateral(\n        uint256 subchainID,\n        address validatorCandidate,\n        uint256 collateralAmount\n    ) external nonReentrant {\n        require(\n            this.isARegisteredSubchain(subchainID),\n            \"the subchainID is not registered yet\"\n        );\n        address guarantor = msg.sender;\n        vcm.depositCollateral(\n            subchainID,\n            validatorCandidate,\n            collateralAmount,\n            guarantor\n        );\n    }\n\n    function withdrawCollateral(\n        uint256 subchainID,\n        address validatorCandidate,\n        uint256 collateralAmount\n    ) external nonReentrant {\n        require(\n            this.isARegisteredSubchain(subchainID),\n            \"the subchainID is not registered yet\"\n        );\n        (bool isAValidator, ) = vsm.getValidatorShares(\n            subchainID,\n            block.number,\n            validatorCandidate\n        );\n        require(\n            !isAValidator,\n            \"collateral withdrawal not allowed for a validator with active stake\"\n        );\n        address guarantor = msg.sender;\n        vcm.withdrawCollateral(\n            subchainID,\n            validatorCandidate,\n            collateralAmount,\n            guarantor\n        );\n    }\n\n    function claimCollateral(uint256 subchainID) external nonReentrant {\n        require(\n            this.isARegisteredSubchain(subchainID),\n            \"the subchainID is not registered yet\"\n        );\n        address guarantor = msg.sender;\n        vcm.claimCollateral(subchainID, guarantor);\n    }\n\n    //\n    // Validator stake deposit/withdrawal/claim\n    //\n\n    function depositStake(\n        uint256 subchainID,\n        address validator,\n        uint256 govTokenAmount\n    ) external payable nonReentrant {\n        require(\n            this.isARegisteredSubchain(subchainID),\n            \"the subchainID is not registered yet\"\n        );\n        require(\n            msg.value >= initialFeeRequired,\n            \"not enough TFuel to cover the initial inter-chain fee\"\n        );\n        // send the initial fees to the validator so it can pay for the gas costs for the initial cross-chain asset transfers\n        // meanwhile, this verifies the validator address can successfully receive TFuel (as oppose to a malicious contract\n        // address which might intentionally revert and can potentially cause issues to the fee split by the TokenBanks).\n        payable(validator).transfer(msg.value);\n        uint256 collateralAmount = vcm.getCollateralAmount(\n            subchainID,\n            validator\n        );\n        require(\n            collateralAmount >= vcm.minValidatorCollateralAmount(),\n            \"need to deposit sufficient wTHETA collateral to a node before staking to it\"\n        );\n        address staker = msg.sender;\n        vsm.depositStake(subchainID, validator, govTokenAmount, staker);\n    }\n\n    function withdrawStake(\n        uint256 subchainID,\n        address validator,\n        uint256 shareAmount\n    ) external nonReentrant {\n        require(\n            this.isARegisteredSubchain(subchainID),\n            \"the subchainID is not registered yet\"\n        );\n        address staker = msg.sender;\n        vsm.withdrawStake(subchainID, validator, shareAmount, staker);\n    }\n\n    function claimStake(uint256 subchainID) external nonReentrant {\n        require(\n            this.isARegisteredSubchain(subchainID),\n            \"the subchainID is not registered yet\"\n        );\n        address staker = msg.sender;\n        vsm.claimStake(subchainID, staker);\n    }\n\n    //\n    // Slash\n    //\n\n    function slashChainCollateral(uint256 subchainID, uint256 slashAmount)\n        external\n        governorOnly\n    {\n        SubchainMetadata storage subchainMetadata = subchainMetadataMap[\n            subchainID\n        ];\n        require(\n            subchainMetadata.exists,\n            \"the subchainID is not registered yet\"\n        );\n        if (subchainMetadata.collateralAmount < slashAmount) {\n            slashAmount = subchainMetadata.collateralAmount;\n        }\n\n        subchainMetadata.collateralAmount = subchainMetadata\n            .collateralAmount\n            .sub(slashAmount);\n        emit SlashChainCollateral(subchainID, slashAmount);\n    }\n\n    function slashValidatorCollateral(\n        uint256 subchainID,\n        address validator,\n        address guarantor,\n        uint256 slashAmount\n    ) external governorOnly {\n        require(\n            this.isARegisteredSubchain(subchainID),\n            \"the subchainID is not registered yet\"\n        );\n        uint256 actualSlashedAmount = vcm.slashCollateral(\n            subchainID,\n            validator,\n            guarantor,\n            slashAmount\n        );\n        emit SlashValidatorCollateral(\n            subchainID,\n            validator,\n            guarantor,\n            actualSlashedAmount\n        );\n    }\n\n    //\n    // Paramter setters\n    //\n\n    function updateSuperAdmin(address newSuperAdmin) external superAdminOnly {\n        superAdmin = newSuperAdmin;\n    }\n\n    function updateAdmin(address newAdmin) external superAdminOnly {\n        admin = newAdmin;\n    }\n\n    function updateGovernor(address newGovernor) external adminOnly {\n        governor = newGovernor;\n    }\n\n    function updateMinChainCollateralAmount(uint256 amount) external adminOnly {\n        minChainCollateralAmount = amount;\n    }\n\n    function updateMinValidatorCollateralAmount(uint256 amount)\n        external\n        adminOnly\n    {\n        vcm.updateMinValidatorCollateralAmount(amount);\n    }\n\n    function updateVCMOwner(address newOwner) external adminOnly {\n        vcm.updateOwner(newOwner);\n    }\n\n    function updateVSMOwner(address newOwner) external adminOnly {\n        vsm.updateOwner(newOwner);\n    }\n\n    function updateCrossChainFee(uint256 newCrossChainFee) external adminOnly {\n        crossChainFee = newCrossChainFee;\n    }\n\n    function updateFallbackReceiver(address newFallbackReceiver)\n        external\n        adminOnly\n    {\n        fallbackReceiver = newFallbackReceiver;\n    }\n\n    function updateSubchainCollateralReturnPercentage(uint256 newPercentage)\n        external\n        adminOnly\n    {\n        require(newPercentage <= 100, \"invalid newPercentage\");\n        subchainCollateralReturnPercentage = newPercentage;\n    }\n\n    //\n    // Utilities\n    //\n\n    function getDynasty()\n        external\n        view\n        returns (uint256 dynasty, bool success)\n    {\n        uint256 mainchainHeight = block.number;\n        dynasty = mainchainHeight / numBlocksPerDynasty;\n        return (dynasty, true);\n    }\n\n    function getCrossChainFee() external view returns (uint256) {\n        return crossChainFee;\n    }\n\n    function getFallbackReceiver() external view returns (address) {\n        return fallbackReceiver;\n    }\n\n    function getAllSubchainIDs() external view returns (uint256[] memory) {\n        return subchainIDs;\n    }\n\n    function isARegisteredSubchain(uint256 subchainID)\n        external\n        view\n        returns (bool)\n    {\n        return subchainMetadataMap[subchainID].exists;\n    }\n\n    function getSubchainMetadata(uint256 subchainID)\n        external\n        view\n        returns (SubchainMetadata memory)\n    {\n        return subchainMetadataMap[subchainID];\n    }\n\n    function getSubchainRegistrationHeight(uint256 subchainID)\n        external\n        view\n        returns (uint256, bool)\n    {\n        SubchainMetadata memory metadata = subchainMetadataMap[subchainID];\n        if (!metadata.exists) {\n            return (0, false);\n        } else {\n            return (metadata.registrationHeight, true);\n        }\n    }\n\n    function getStakeSnapshotHeights(uint256 subchainID)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return vsm.getStakeSnapshotHeights(subchainID);\n    }\n\n    function getNumBlocksPerDynasty() external view returns (uint256) {\n        return vsm.numBlocksPerDynasty();\n    }\n\n    function getStakeSnapshot(uint256 subchainID, uint256 blockHeight)\n        external\n        view\n        returns (\n            bool exists,\n            uint256 targetSnapshotHeight,\n            ValidatorStakeManager.StakeSnapshot memory targetStakeSnapshot\n        )\n    {\n        return vsm.getStakeSnapshot(subchainID, blockHeight);\n    }\n\n    // query the validator set of a subchain at a given block height\n    function getValidatorSet(uint256 subchainID, uint256 dynasty)\n        external\n        view\n        returns (address[] memory validators, uint256[] memory shareAmounts)\n    {\n        return vsm.getValidatorSet(subchainID, dynasty);\n    }\n\n    // query the total amount of shares of a subchain at a given block height\n    function getTotalValidatorShares(uint256 subchainID, uint256 dynasty)\n        external\n        view\n        returns (uint256)\n    {\n        (, uint256[] memory shares) = this.getValidatorSet(subchainID, dynasty);\n        uint256 numValidators = shares.length;\n        uint256 totalShares = 0;\n        for (uint256 i = 0; i < numValidators; i++) {\n            totalShares = totalShares.add(shares[i]);\n        }\n        return totalShares;\n    }\n\n    // query the shares of a validator of a subchain at the given block height\n    function getValidatorShares(\n        uint256 subchainID,\n        uint256 blockHeight,\n        address validator\n    ) external view returns (bool isAValidator, uint256 shareAmount) {\n        (isAValidator, shareAmount) = vsm.getValidatorShares(\n            subchainID,\n            blockHeight,\n            validator\n        );\n        return (isAValidator, shareAmount);\n    }\n\n    function getValidatorGuarantorsWithPendingWithdrawals(uint256 subchainID)\n        external\n        view\n        returns (address[] memory)\n    {\n        return vcm.getWithdrawalQueue(subchainID).allReceivers();\n    }\n\n    function getPendingValidatorCollateralWithdrawals(\n        uint256 subchainID,\n        address guarantor\n    ) external view returns (WithdrawalQueue.WithdrawalRequest[] memory) {\n        return\n            vcm.getWithdrawalQueue(subchainID).getWithdrawalRequests(guarantor);\n    }\n\n    function getStakersWithPendingWithdrawals(uint256 subchainID)\n        external\n        view\n        returns (address[] memory)\n    {\n        return vsm.getWithdrawalQueue(subchainID).allReceivers();\n    }\n\n    function getPendingStakeWithdrawals(uint256 subchainID, address staker)\n        external\n        view\n        returns (WithdrawalQueue.WithdrawalRequest[] memory)\n    {\n        return vsm.getWithdrawalQueue(subchainID).getWithdrawalRequests(staker);\n    }\n\n    //\n    // Modifiers\n    //\n\n    modifier superAdminOnly() {\n        require(\n            msg.sender == superAdmin,\n            \"Only super admin can make this call\"\n        );\n        _;\n    }\n\n    modifier adminOnly() {\n        require(msg.sender == admin, \"Only admin can make this call\");\n        _;\n    }\n\n    modifier governorOnly() {\n        require(msg.sender == governor, \"Only governor can make this call\");\n        _;\n    }